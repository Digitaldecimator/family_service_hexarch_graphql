package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"encoding/base64"
	"fmt"
	"strings"
	"time"

	"github.com/abitofhelp/family-service2/internal/domain"
	"github.com/abitofhelp/family-service2/internal/ports"
	"github.com/google/uuid"
	"go.opentelemetry.io/otel/attribute"
	"go.uber.org/zap"
)

// ID is the resolver for the id field.
func (r *childResolver) ID(ctx context.Context, obj *domain.Child) (string, error) {
	return obj.ID.String(), nil
}

// BirthDate is the resolver for the birthDate field.
func (r *childResolver) BirthDate(ctx context.Context, obj *domain.Child) (string, error) {
	return obj.BirthDate.Format(time.RFC3339), nil
}

// ParentID is the resolver for the parentId field.
func (r *childResolver) ParentID(ctx context.Context, obj *domain.Child) (string, error) {
	return obj.ParentID.String(), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *childResolver) CreatedAt(ctx context.Context, obj *domain.Child) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *childResolver) UpdatedAt(ctx context.Context, obj *domain.Child) (string, error) {
	return obj.UpdatedAt.Format(time.RFC3339), nil
}

// Edges is the resolver for the edges field.
func (r *childConnectionResolver) Edges(ctx context.Context, obj *ChildConnection) ([]ChildEdge, error) {
	return obj.Edges, nil
}

// PageInfo is the resolver for the pageInfo field.
func (r *childConnectionResolver) PageInfo(ctx context.Context, obj *ChildConnection) (*PageInfo, error) {
	return obj.PageInfo, nil
}

// TotalCount is the resolver for the totalCount field.
func (r *childConnectionResolver) TotalCount(ctx context.Context, obj *ChildConnection) (int, error) {
	return obj.TotalCount, nil
}

// CreateParent is the resolver for the createParent field.
func (r *mutationResolver) CreateParent(ctx context.Context, input CreateParentInput) (*domain.Parent, error) {
	// Validate context
	if ctx == nil {
		return nil, fmt.Errorf("nil context provided to CreateParent")
	}

	// Create a span for this operation
	ctx, span := r.tracer.Start(ctx, "Mutation.CreateParent")
	defer span.End()

	// Add operation attributes to the span
	span.SetAttributes(
		attribute.String("firstName", input.FirstName),
		attribute.String("lastName", input.LastName),
		attribute.String("email", input.Email),
	)

	// Create a timeout for this operation
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Check authorization
	authorized, err := r.authService.IsAuthorized(ctx, "parent:create")
	if err != nil {
		r.logger.Error("Failed to check authorization", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to check authorization: %w", err)
	}
	if !authorized {
		err := fmt.Errorf("not authorized to create parent")
		span.RecordError(err)
		return nil, err
	}

	// Create parent
	parent, err := r.familyService.CreateParent(ctx, input.FirstName, input.LastName, input.Email, input.BirthDate)
	if err != nil {
		r.logger.Error("Failed to create parent", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to create parent: %w", err)
	}

	// Add success attribute to the span
	span.SetAttributes(attribute.String("parent.id", parent.ID.String()))

	return parent, nil
}

// UpdateParent is the resolver for the updateParent field.
func (r *mutationResolver) UpdateParent(ctx context.Context, id string, input UpdateParentInput) (*domain.Parent, error) {
	// Validate context
	if ctx == nil {
		return nil, fmt.Errorf("nil context provided to UpdateParent")
	}

	// Create a span for this operation
	ctx, span := r.tracer.Start(ctx, "Mutation.UpdateParent")
	defer span.End()

	// Add operation attributes to the span
	span.SetAttributes(attribute.String("parent.id", id))

	// Create a timeout for this operation
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Check authorization
	authorized, err := r.authService.IsAuthorized(ctx, "parent:update")
	if err != nil {
		r.logger.Error("Failed to check authorization", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to check authorization: %w", err)
	}
	if !authorized {
		err := fmt.Errorf("not authorized to update parent")
		span.RecordError(err)
		return nil, err
	}

	// Convert ID string to UUID
	parentID, err := uuid.Parse(id)
	if err != nil {
		r.logger.Error("Invalid parent ID", zap.Error(err), zap.String("id", id))
		span.RecordError(err)
		return nil, fmt.Errorf("invalid parent ID: %w", err)
	}

	// Get current values
	parent, err := r.familyService.GetParentByID(ctx, parentID)
	if err != nil {
		r.logger.Error("Failed to get parent", zap.Error(err), zap.String("id", id))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to get parent: %w", err)
	}

	// Update with new values if provided
	firstName := parent.FirstName
	if input.FirstName != nil {
		firstName = *input.FirstName
		span.SetAttributes(attribute.String("firstName", firstName))
	}

	lastName := parent.LastName
	if input.LastName != nil {
		lastName = *input.LastName
		span.SetAttributes(attribute.String("lastName", lastName))
	}

	email := parent.Email
	if input.Email != nil {
		email = *input.Email
		span.SetAttributes(attribute.String("email", email))
	}

	birthDate := parent.BirthDate.Format(time.RFC3339)
	if input.BirthDate != nil {
		birthDate = *input.BirthDate
		span.SetAttributes(attribute.String("birthDate", birthDate))
	}

	// Check for context cancellation before proceeding
	select {
	case <-ctx.Done():
		err := ctx.Err()
		r.logger.Error("Context cancelled or timed out", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("operation cancelled or timed out: %w", err)
	default:
		// Continue with the operation
	}

	// Update parent
	updatedParent, err := r.familyService.UpdateParent(ctx, parentID, firstName, lastName, email, birthDate)
	if err != nil {
		r.logger.Error("Failed to update parent", zap.Error(err), zap.String("id", id))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to update parent: %w", err)
	}

	// Add success attribute to the span
	span.SetAttributes(attribute.String("result", "success"))

	return updatedParent, nil
}

// DeleteParent is the resolver for the deleteParent field.
func (r *mutationResolver) DeleteParent(ctx context.Context, id string) (bool, error) {
	// Validate context
	if ctx == nil {
		return false, fmt.Errorf("nil context provided to DeleteParent")
	}

	// Create a span for this operation
	ctx, span := r.tracer.Start(ctx, "Mutation.DeleteParent")
	defer span.End()

	// Add operation attributes to the span
	span.SetAttributes(attribute.String("parent.id", id))

	// Create a timeout for this operation
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Check authorization
	authorized, err := r.authService.IsAuthorized(ctx, "parent:delete")
	if err != nil {
		r.logger.Error("Failed to check authorization", zap.Error(err))
		span.RecordError(err)
		return false, fmt.Errorf("failed to check authorization: %w", err)
	}
	if !authorized {
		err := fmt.Errorf("not authorized to delete parent")
		span.RecordError(err)
		return false, err
	}

	// Convert ID string to UUID
	parentID, err := uuid.Parse(id)
	if err != nil {
		r.logger.Error("Invalid parent ID", zap.Error(err), zap.String("id", id))
		span.RecordError(err)
		return false, fmt.Errorf("invalid parent ID: %w", err)
	}

	// Check for context cancellation before proceeding
	select {
	case <-ctx.Done():
		err := ctx.Err()
		r.logger.Error("Context cancelled or timed out", zap.Error(err))
		span.RecordError(err)
		return false, fmt.Errorf("operation cancelled or timed out: %w", err)
	default:
		// Continue with the operation
	}

	// Delete parent
	err = r.familyService.DeleteParent(ctx, parentID)
	if err != nil {
		r.logger.Error("Failed to delete parent", zap.Error(err), zap.String("id", id))
		span.RecordError(err)
		return false, fmt.Errorf("failed to delete parent: %w", err)
	}

	// Add success attribute to the span
	span.SetAttributes(attribute.String("result", "success"))

	return true, nil
}

// CreateChild is the resolver for the createChild field.
func (r *mutationResolver) CreateChild(ctx context.Context, input CreateChildInput) (*domain.Child, error) {
	// Validate context
	if ctx == nil {
		return nil, fmt.Errorf("nil context provided to CreateChild")
	}

	// Create a span for this operation
	ctx, span := r.tracer.Start(ctx, "Mutation.CreateChild")
	defer span.End()

	// Add operation attributes to the span
	span.SetAttributes(
		attribute.String("firstName", input.FirstName),
		attribute.String("lastName", input.LastName),
		attribute.String("parentId", input.ParentID),
	)

	// Create a timeout for this operation
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Check authorization
	authorized, err := r.authService.IsAuthorized(ctx, "child:create")
	if err != nil {
		r.logger.Error("Failed to check authorization", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to check authorization: %w", err)
	}
	if !authorized {
		err := fmt.Errorf("not authorized to create child")
		span.RecordError(err)
		return nil, err
	}

	// Convert parent ID string to UUID
	parentID, err := uuid.Parse(input.ParentID)
	if err != nil {
		r.logger.Error("Invalid parent ID", zap.Error(err), zap.String("parentId", input.ParentID))
		span.RecordError(err)
		return nil, fmt.Errorf("invalid parent ID: %w", err)
	}

	// Check for context cancellation before proceeding
	select {
	case <-ctx.Done():
		err := ctx.Err()
		r.logger.Error("Context cancelled or timed out", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("operation cancelled or timed out: %w", err)
	default:
		// Continue with the operation
	}

	// Create child
	child, err := r.familyService.CreateChild(ctx, input.FirstName, input.LastName, input.BirthDate, parentID)
	if err != nil {
		r.logger.Error("Failed to create child", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to create child: %w", err)
	}

	// Add success attribute to the span
	span.SetAttributes(attribute.String("child.id", child.ID.String()))

	return child, nil
}

// UpdateChild is the resolver for the updateChild field.
func (r *mutationResolver) UpdateChild(ctx context.Context, id string, input UpdateChildInput) (*domain.Child, error) {
	// Validate context
	if ctx == nil {
		return nil, fmt.Errorf("nil context provided to UpdateChild")
	}

	// Create a span for this operation
	ctx, span := r.tracer.Start(ctx, "Mutation.UpdateChild")
	defer span.End()

	// Add operation attributes to the span
	span.SetAttributes(attribute.String("child.id", id))

	// Create a timeout for this operation
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Check authorization
	authorized, err := r.authService.IsAuthorized(ctx, "child:update")
	if err != nil {
		r.logger.Error("Failed to check authorization", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to check authorization: %w", err)
	}
	if !authorized {
		err := fmt.Errorf("not authorized to update child")
		span.RecordError(err)
		return nil, err
	}

	// Convert ID string to UUID
	childID, err := uuid.Parse(id)
	if err != nil {
		r.logger.Error("Invalid child ID", zap.Error(err), zap.String("id", id))
		span.RecordError(err)
		return nil, fmt.Errorf("invalid child ID: %w", err)
	}

	// Get current values
	child, err := r.familyService.GetChildByID(ctx, childID)
	if err != nil {
		r.logger.Error("Failed to get child", zap.Error(err), zap.String("id", id))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to get child: %w", err)
	}

	// Update with new values if provided
	firstName := child.FirstName
	if input.FirstName != nil {
		firstName = *input.FirstName
		span.SetAttributes(attribute.String("firstName", firstName))
	}

	lastName := child.LastName
	if input.LastName != nil {
		lastName = *input.LastName
		span.SetAttributes(attribute.String("lastName", lastName))
	}

	birthDate := child.BirthDate.Format(time.RFC3339)
	if input.BirthDate != nil {
		birthDate = *input.BirthDate
		span.SetAttributes(attribute.String("birthDate", birthDate))
	}

	// Check for context cancellation before proceeding
	select {
	case <-ctx.Done():
		err := ctx.Err()
		r.logger.Error("Context cancelled or timed out", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("operation cancelled or timed out: %w", err)
	default:
		// Continue with the operation
	}

	// Update child
	updatedChild, err := r.familyService.UpdateChild(ctx, childID, firstName, lastName, birthDate)
	if err != nil {
		r.logger.Error("Failed to update child", zap.Error(err), zap.String("id", id))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to update child: %w", err)
	}

	// Add success attribute to the span
	span.SetAttributes(attribute.String("result", "success"))

	return updatedChild, nil
}

// DeleteChild is the resolver for the deleteChild field.
func (r *mutationResolver) DeleteChild(ctx context.Context, id string) (bool, error) {
	// Validate context
	if ctx == nil {
		return false, fmt.Errorf("nil context provided to DeleteChild")
	}

	// Create a span for this operation
	ctx, span := r.tracer.Start(ctx, "Mutation.DeleteChild")
	defer span.End()

	// Add operation attributes to the span
	span.SetAttributes(attribute.String("child.id", id))

	// Create a timeout for this operation
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Check authorization
	authorized, err := r.authService.IsAuthorized(ctx, "child:delete")
	if err != nil {
		r.logger.Error("Failed to check authorization", zap.Error(err))
		span.RecordError(err)
		return false, fmt.Errorf("failed to check authorization: %w", err)
	}
	if !authorized {
		err := fmt.Errorf("not authorized to delete child")
		span.RecordError(err)
		return false, err
	}

	// Convert ID string to UUID
	childID, err := uuid.Parse(id)
	if err != nil {
		r.logger.Error("Invalid child ID", zap.Error(err), zap.String("id", id))
		span.RecordError(err)
		return false, fmt.Errorf("invalid child ID: %w", err)
	}

	// Check for context cancellation before proceeding
	select {
	case <-ctx.Done():
		err := ctx.Err()
		r.logger.Error("Context cancelled or timed out", zap.Error(err))
		span.RecordError(err)
		return false, fmt.Errorf("operation cancelled or timed out: %w", err)
	default:
		// Continue with the operation
	}

	// Delete child
	err = r.familyService.DeleteChild(ctx, childID)
	if err != nil {
		r.logger.Error("Failed to delete child", zap.Error(err), zap.String("id", id))
		span.RecordError(err)
		return false, fmt.Errorf("failed to delete child: %w", err)
	}

	// Add success attribute to the span
	span.SetAttributes(attribute.String("result", "success"))

	return true, nil
}

// AddChildToParent is the resolver for the addChildToParent field.
func (r *mutationResolver) AddChildToParent(ctx context.Context, parentID string, childID string) (bool, error) {
	// Validate context
	if ctx == nil {
		return false, fmt.Errorf("nil context provided to AddChildToParent")
	}

	// Create a span for this operation
	ctx, span := r.tracer.Start(ctx, "Mutation.AddChildToParent")
	defer span.End()

	// Add operation attributes to the span
	span.SetAttributes(
		attribute.String("parent.id", parentID),
		attribute.String("child.id", childID),
	)

	// Create a timeout for this operation
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Check authorization
	authorized, err := r.authService.IsAuthorized(ctx, "parent:update")
	if err != nil {
		r.logger.Error("Failed to check authorization", zap.Error(err))
		span.RecordError(err)
		return false, fmt.Errorf("failed to check authorization: %w", err)
	}
	if !authorized {
		err := fmt.Errorf("not authorized to update parent")
		span.RecordError(err)
		return false, err
	}

	// Convert parent ID string to UUID
	parentUUID, err := uuid.Parse(parentID)
	if err != nil {
		r.logger.Error("Invalid parent ID", zap.Error(err), zap.String("parentId", parentID))
		span.RecordError(err)
		return false, fmt.Errorf("invalid parent ID: %w", err)
	}

	// Convert child ID string to UUID
	childUUID, err := uuid.Parse(childID)
	if err != nil {
		r.logger.Error("Invalid child ID", zap.Error(err), zap.String("childId", childID))
		span.RecordError(err)
		return false, fmt.Errorf("invalid child ID: %w", err)
	}

	// Check for context cancellation before proceeding
	select {
	case <-ctx.Done():
		err := ctx.Err()
		r.logger.Error("Context cancelled or timed out", zap.Error(err))
		span.RecordError(err)
		return false, fmt.Errorf("operation cancelled or timed out: %w", err)
	default:
		// Continue with the operation
	}

	// Add child to parent
	err = r.familyService.AddChildToParent(ctx, parentUUID, childUUID)
	if err != nil {
		r.logger.Error("Failed to add child to parent", zap.Error(err), zap.String("parentId", parentID), zap.String("childId", childID))
		span.RecordError(err)
		return false, fmt.Errorf("failed to add child to parent: %w", err)
	}

	// Add success attribute to the span
	span.SetAttributes(attribute.String("result", "success"))

	return true, nil
}

// RemoveChildFromParent is the resolver for the removeChildFromParent field.
func (r *mutationResolver) RemoveChildFromParent(ctx context.Context, parentID string, childID string) (bool, error) {
	// Validate context
	if ctx == nil {
		return false, fmt.Errorf("nil context provided to RemoveChildFromParent")
	}

	// Create a span for this operation
	ctx, span := r.tracer.Start(ctx, "Mutation.RemoveChildFromParent")
	defer span.End()

	// Add operation attributes to the span
	span.SetAttributes(
		attribute.String("parent.id", parentID),
		attribute.String("child.id", childID),
	)

	// Create a timeout for this operation
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Check authorization
	authorized, err := r.authService.IsAuthorized(ctx, "parent:update")
	if err != nil {
		r.logger.Error("Failed to check authorization", zap.Error(err))
		span.RecordError(err)
		return false, fmt.Errorf("failed to check authorization: %w", err)
	}
	if !authorized {
		err := fmt.Errorf("not authorized to update parent")
		span.RecordError(err)
		return false, err
	}

	// Convert parent ID string to UUID
	parentUUID, err := uuid.Parse(parentID)
	if err != nil {
		r.logger.Error("Invalid parent ID", zap.Error(err), zap.String("parentId", parentID))
		span.RecordError(err)
		return false, fmt.Errorf("invalid parent ID: %w", err)
	}

	// Convert child ID string to UUID
	childUUID, err := uuid.Parse(childID)
	if err != nil {
		r.logger.Error("Invalid child ID", zap.Error(err), zap.String("childId", childID))
		span.RecordError(err)
		return false, fmt.Errorf("invalid child ID: %w", err)
	}

	// Check for context cancellation before proceeding
	select {
	case <-ctx.Done():
		err := ctx.Err()
		r.logger.Error("Context cancelled or timed out", zap.Error(err))
		span.RecordError(err)
		return false, fmt.Errorf("operation cancelled or timed out: %w", err)
	default:
		// Continue with the operation
	}

	// Remove child from parent
	err = r.familyService.RemoveChildFromParent(ctx, parentUUID, childUUID)
	if err != nil {
		r.logger.Error("Failed to remove child from parent", zap.Error(err), zap.String("parentId", parentID), zap.String("childId", childID))
		span.RecordError(err)
		return false, fmt.Errorf("failed to remove child from parent: %w", err)
	}

	// Add success attribute to the span
	span.SetAttributes(attribute.String("result", "success"))

	return true, nil
}

// ID is the resolver for the id field.
func (r *parentResolver) ID(ctx context.Context, obj *domain.Parent) (string, error) {
	return obj.ID.String(), nil
}

// BirthDate is the resolver for the birthDate field.
func (r *parentResolver) BirthDate(ctx context.Context, obj *domain.Parent) (string, error) {
	return obj.BirthDate.Format(time.RFC3339), nil
}

// Children is the resolver for the children field.
func (r *parentResolver) Children(ctx context.Context, obj *domain.Parent) ([]domain.Child, error) {
	return obj.Children, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *parentResolver) CreatedAt(ctx context.Context, obj *domain.Parent) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *parentResolver) UpdatedAt(ctx context.Context, obj *domain.Parent) (string, error) {
	return obj.UpdatedAt.Format(time.RFC3339), nil
}

// Edges is the resolver for the edges field.
func (r *parentConnectionResolver) Edges(ctx context.Context, obj *ParentConnection) ([]ParentEdge, error) {
	return obj.Edges, nil
}

// PageInfo is the resolver for the pageInfo field.
func (r *parentConnectionResolver) PageInfo(ctx context.Context, obj *ParentConnection) (*PageInfo, error) {
	return obj.PageInfo, nil
}

// TotalCount is the resolver for the totalCount field.
func (r *parentConnectionResolver) TotalCount(ctx context.Context, obj *ParentConnection) (int, error) {
	return obj.TotalCount, nil
}

// Parent is the resolver for the parent field.
func (r *queryResolver) Parent(ctx context.Context, id string) (*domain.Parent, error) {
	// Validate context
	if ctx == nil {
		return nil, fmt.Errorf("nil context provided to Parent query")
	}

	// Create a span for this operation
	ctx, span := r.tracer.Start(ctx, "Query.Parent")
	defer span.End()

	// Add operation attributes to the span
	span.SetAttributes(attribute.String("parent.id", id))

	// Create a timeout for this operation
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Check authorization
	authorized, err := r.authService.IsAuthorized(ctx, "parent:read")
	if err != nil {
		r.logger.Error("Failed to check authorization", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to check authorization: %w", err)
	}
	if !authorized {
		err := fmt.Errorf("not authorized to read parent")
		span.RecordError(err)
		return nil, err
	}

	// Convert ID string to UUID
	parentID, err := uuid.Parse(id)
	if err != nil {
		r.logger.Error("Invalid parent ID", zap.Error(err), zap.String("id", id))
		span.RecordError(err)
		return nil, fmt.Errorf("invalid parent ID: %w", err)
	}

	// Check for context cancellation before proceeding
	select {
	case <-ctx.Done():
		err := ctx.Err()
		r.logger.Error("Context cancelled or timed out", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("operation cancelled or timed out: %w", err)
	default:
		// Continue with the operation
	}

	// Get parent by ID
	parent, err := r.familyService.GetParentByID(ctx, parentID)
	if err != nil {
		r.logger.Error("Failed to get parent", zap.Error(err), zap.String("id", id))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to get parent: %w", err)
	}

	// Add success attribute to the span
	span.SetAttributes(attribute.String("result", "success"))

	return parent, nil
}

// Parents is the resolver for the parents field.
func (r *queryResolver) Parents(ctx context.Context, filter *ParentFilter, pagination *PaginationInput, sort *SortInput) (*ParentConnection, error) {
	// Validate context
	if ctx == nil {
		return nil, fmt.Errorf("nil context provided to Parents query")
	}

	// Create a span for this operation
	ctx, span := r.tracer.Start(ctx, "Query.Parents")
	defer span.End()

	// Create a timeout for this operation
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Check authorization
	authorized, err := r.authService.IsAuthorized(ctx, "parent:list")
	if err != nil {
		r.logger.Error("Failed to check authorization", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to check authorization: %w", err)
	}
	if !authorized {
		err := fmt.Errorf("not authorized to list parents")
		span.RecordError(err)
		return nil, err
	}

	// Check for context cancellation before proceeding
	select {
	case <-ctx.Done():
		err := ctx.Err()
		r.logger.Error("Context cancelled or timed out", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("operation cancelled or timed out: %w", err)
	default:
		// Continue with the operation
	}

	// Convert GraphQL filter to domain filter
	filterOptions := ports.FilterOptions{}
	if filter != nil {
		if filter.FirstName != nil {
			filterOptions.FirstName = *filter.FirstName
		}
		if filter.LastName != nil {
			filterOptions.LastName = *filter.LastName
		}
		if filter.Email != nil {
			filterOptions.Email = *filter.Email
		}
		if filter.MinAge != nil {
			filterOptions.MinAge = *filter.MinAge
		}
		if filter.MaxAge != nil {
			filterOptions.MaxAge = *filter.MaxAge
		}
	}

	// Convert GraphQL pagination to domain pagination
	paginationOptions := ports.PaginationOptions{
		Page:     0,
		PageSize: 10,
	}
	if pagination != nil {
		if pagination.Page != nil {
			paginationOptions.Page = *pagination.Page
		}
		if pagination.PageSize != nil {
			paginationOptions.PageSize = *pagination.PageSize
		}
	}

	// Convert GraphQL sort to domain sort
	sortOptions := ports.SortOptions{
		Field:     "createdAt",
		Direction: "desc",
	}
	if sort != nil {
		if sort.Field != nil {
			sortOptions.Field = *sort.Field
		}
		if sort.Direction != nil {
			sortOptions.Direction = strings.ToLower(string(*sort.Direction))
		}
	}

	// Create query options
	queryOptions := ports.QueryOptions{
		Filter:     filterOptions,
		Pagination: paginationOptions,
		Sort:       sortOptions,
	}

	// List parents
	parents, pagedResult, err := r.familyService.ListParents(ctx, queryOptions)
	if err != nil {
		r.logger.Error("Failed to list parents", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to list parents: %w", err)
	}

	// Create connection
	connection := &ParentConnection{
		Edges:      make([]ParentEdge, len(parents)),
		PageInfo:   &PageInfo{},
		TotalCount: int(pagedResult.TotalCount),
	}

	// Create edges
	for i, parent := range parents {
		connection.Edges[i] = ParentEdge{
			Node:   parent,
			Cursor: encodeCursor(parent.ID.String()),
		}
	}

	// Set page info
	connection.PageInfo.HasNextPage = pagedResult.HasNext
	connection.PageInfo.HasPreviousPage = pagedResult.Page > 0
	if len(parents) > 0 {
		startCursor := encodeCursor(parents[0].ID.String())
		endCursor := encodeCursor(parents[len(parents)-1].ID.String())
		connection.PageInfo.StartCursor = &startCursor
		connection.PageInfo.EndCursor = &endCursor
	}

	return connection, nil
}

// Child is the resolver for the child field.
func (r *queryResolver) Child(ctx context.Context, id string) (*domain.Child, error) {
	// Validate context
	if ctx == nil {
		return nil, fmt.Errorf("nil context provided to Child query")
	}

	// Create a span for this operation
	ctx, span := r.tracer.Start(ctx, "Query.Child")
	defer span.End()

	// Add operation attributes to the span
	span.SetAttributes(attribute.String("child.id", id))

	// Create a timeout for this operation
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Check authorization
	authorized, err := r.authService.IsAuthorized(ctx, "child:read")
	if err != nil {
		r.logger.Error("Failed to check authorization", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to check authorization: %w", err)
	}
	if !authorized {
		err := fmt.Errorf("not authorized to read child")
		span.RecordError(err)
		return nil, err
	}

	// Convert ID string to UUID
	childID, err := uuid.Parse(id)
	if err != nil {
		r.logger.Error("Invalid child ID", zap.Error(err), zap.String("id", id))
		span.RecordError(err)
		return nil, fmt.Errorf("invalid child ID: %w", err)
	}

	// Check for context cancellation before proceeding
	select {
	case <-ctx.Done():
		err := ctx.Err()
		r.logger.Error("Context cancelled or timed out", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("operation cancelled or timed out: %w", err)
	default:
		// Continue with the operation
	}

	// Get child by ID
	child, err := r.familyService.GetChildByID(ctx, childID)
	if err != nil {
		r.logger.Error("Failed to get child", zap.Error(err), zap.String("id", id))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to get child: %w", err)
	}

	// Add success attribute to the span
	span.SetAttributes(attribute.String("result", "success"))

	return child, nil
}

// Children is the resolver for the children field.
func (r *queryResolver) Children(ctx context.Context, filter *ChildFilter, pagination *PaginationInput, sort *SortInput) (*ChildConnection, error) {
	// Validate context
	if ctx == nil {
		return nil, fmt.Errorf("nil context provided to Children query")
	}

	// Create a span for this operation
	ctx, span := r.tracer.Start(ctx, "Query.Children")
	defer span.End()

	// Create a timeout for this operation
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Check authorization
	authorized, err := r.authService.IsAuthorized(ctx, "child:list")
	if err != nil {
		r.logger.Error("Failed to check authorization", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to check authorization: %w", err)
	}
	if !authorized {
		err := fmt.Errorf("not authorized to list children")
		span.RecordError(err)
		return nil, err
	}

	// Check for context cancellation before proceeding
	select {
	case <-ctx.Done():
		err := ctx.Err()
		r.logger.Error("Context cancelled or timed out", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("operation cancelled or timed out: %w", err)
	default:
		// Continue with the operation
	}

	// Convert GraphQL filter to domain filter
	filterOptions := ports.FilterOptions{}
	if filter != nil {
		if filter.FirstName != nil {
			filterOptions.FirstName = *filter.FirstName
		}
		if filter.LastName != nil {
			filterOptions.LastName = *filter.LastName
		}
		if filter.MinAge != nil {
			filterOptions.MinAge = *filter.MinAge
		}
		if filter.MaxAge != nil {
			filterOptions.MaxAge = *filter.MaxAge
		}
	}

	// Convert GraphQL pagination to domain pagination
	paginationOptions := ports.PaginationOptions{
		Page:     0,
		PageSize: 10,
	}
	if pagination != nil {
		if pagination.Page != nil {
			paginationOptions.Page = *pagination.Page
		}
		if pagination.PageSize != nil {
			paginationOptions.PageSize = *pagination.PageSize
		}
	}

	// Convert GraphQL sort to domain sort
	sortOptions := ports.SortOptions{
		Field:     "createdAt",
		Direction: "desc",
	}
	if sort != nil {
		if sort.Field != nil {
			sortOptions.Field = *sort.Field
		}
		if sort.Direction != nil {
			sortOptions.Direction = strings.ToLower(string(*sort.Direction))
		}
	}

	// Create query options
	queryOptions := ports.QueryOptions{
		Filter:     filterOptions,
		Pagination: paginationOptions,
		Sort:       sortOptions,
	}

	// List children
	children, pagedResult, err := r.familyService.ListChildren(ctx, queryOptions)
	if err != nil {
		r.logger.Error("Failed to list children", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to list children: %w", err)
	}

	// Create connection
	connection := &ChildConnection{
		Edges:      make([]ChildEdge, len(children)),
		PageInfo:   &PageInfo{},
		TotalCount: int(pagedResult.TotalCount),
	}

	// Create edges
	for i, child := range children {
		connection.Edges[i] = ChildEdge{
			Node:   child,
			Cursor: encodeCursor(child.ID.String()),
		}
	}

	// Set page info
	connection.PageInfo.HasNextPage = pagedResult.HasNext
	connection.PageInfo.HasPreviousPage = pagedResult.Page > 0
	if len(children) > 0 {
		startCursor := encodeCursor(children[0].ID.String())
		endCursor := encodeCursor(children[len(children)-1].ID.String())
		connection.PageInfo.StartCursor = &startCursor
		connection.PageInfo.EndCursor = &endCursor
	}

	return connection, nil
}

// ChildrenByParent is the resolver for the childrenByParent field.
func (r *queryResolver) ChildrenByParent(ctx context.Context, parentID string, filter *ChildFilter, pagination *PaginationInput, sort *SortInput) (*ChildConnection, error) {
	// Validate context
	if ctx == nil {
		return nil, fmt.Errorf("nil context provided to ChildrenByParent query")
	}

	// Create a span for this operation
	ctx, span := r.tracer.Start(ctx, "Query.ChildrenByParent")
	defer span.End()

	// Add operation attributes to the span
	span.SetAttributes(attribute.String("parent.id", parentID))

	// Create a timeout for this operation
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	// Check authorization
	authorized, err := r.authService.IsAuthorized(ctx, "child:list")
	if err != nil {
		r.logger.Error("Failed to check authorization", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to check authorization: %w", err)
	}
	if !authorized {
		err := fmt.Errorf("not authorized to list children")
		span.RecordError(err)
		return nil, err
	}

	// Convert parent ID string to UUID
	parentUUID, err := uuid.Parse(parentID)
	if err != nil {
		r.logger.Error("Invalid parent ID", zap.Error(err), zap.String("parentId", parentID))
		span.RecordError(err)
		return nil, fmt.Errorf("invalid parent ID: %w", err)
	}

	// Check for context cancellation before proceeding
	select {
	case <-ctx.Done():
		err := ctx.Err()
		r.logger.Error("Context cancelled or timed out", zap.Error(err))
		span.RecordError(err)
		return nil, fmt.Errorf("operation cancelled or timed out: %w", err)
	default:
		// Continue with the operation
	}

	// Convert GraphQL filter to domain filter
	filterOptions := ports.FilterOptions{}
	if filter != nil {
		if filter.FirstName != nil {
			filterOptions.FirstName = *filter.FirstName
		}
		if filter.LastName != nil {
			filterOptions.LastName = *filter.LastName
		}
		if filter.MinAge != nil {
			filterOptions.MinAge = *filter.MinAge
		}
		if filter.MaxAge != nil {
			filterOptions.MaxAge = *filter.MaxAge
		}
	}

	// Convert GraphQL pagination to domain pagination
	paginationOptions := ports.PaginationOptions{
		Page:     0,
		PageSize: 10,
	}
	if pagination != nil {
		if pagination.Page != nil {
			paginationOptions.Page = *pagination.Page
		}
		if pagination.PageSize != nil {
			paginationOptions.PageSize = *pagination.PageSize
		}
	}

	// Convert GraphQL sort to domain sort
	sortOptions := ports.SortOptions{
		Field:     "createdAt",
		Direction: "desc",
	}
	if sort != nil {
		if sort.Field != nil {
			sortOptions.Field = *sort.Field
		}
		if sort.Direction != nil {
			sortOptions.Direction = strings.ToLower(string(*sort.Direction))
		}
	}

	// Create query options
	queryOptions := ports.QueryOptions{
		Filter:     filterOptions,
		Pagination: paginationOptions,
		Sort:       sortOptions,
	}

	// List children by parent ID
	children, pagedResult, err := r.familyService.ListChildrenByParentID(ctx, parentUUID, queryOptions)
	if err != nil {
		r.logger.Error("Failed to list children by parent", zap.Error(err), zap.String("parentId", parentID))
		span.RecordError(err)
		return nil, fmt.Errorf("failed to list children by parent: %w", err)
	}

	// Create connection
	connection := &ChildConnection{
		Edges:      make([]ChildEdge, len(children)),
		PageInfo:   &PageInfo{},
		TotalCount: int(pagedResult.TotalCount),
	}

	// Create edges
	for i, child := range children {
		connection.Edges[i] = ChildEdge{
			Node:   child,
			Cursor: encodeCursor(child.ID.String()),
		}
	}

	// Set page info
	connection.PageInfo.HasNextPage = pagedResult.HasNext
	connection.PageInfo.HasPreviousPage = pagedResult.Page > 0
	if len(children) > 0 {
		startCursor := encodeCursor(children[0].ID.String())
		endCursor := encodeCursor(children[len(children)-1].ID.String())
		connection.PageInfo.StartCursor = &startCursor
		connection.PageInfo.EndCursor = &endCursor
	}

	return connection, nil
}

// Child returns ChildResolver implementation.
func (r *Resolver) Child() ChildResolver { return &childResolver{r} }

// ChildConnection returns ChildConnectionResolver implementation.
func (r *Resolver) ChildConnection() ChildConnectionResolver { return &childConnectionResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Parent returns ParentResolver implementation.
func (r *Resolver) Parent() ParentResolver { return &parentResolver{r} }

// ParentConnection returns ParentConnectionResolver implementation.
func (r *Resolver) ParentConnection() ParentConnectionResolver { return &parentConnectionResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type childResolver struct{ *Resolver }
type childConnectionResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type parentResolver struct{ *Resolver }
type parentConnectionResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.

func encodeCursor(s string) string {
	return base64.StdEncoding.EncodeToString([]byte(s))
}
func decodeCursor(s string) (string, error) {
	b, err := base64.StdEncoding.DecodeString(s)
	if err != nil {
		return "", err
	}
	return string(b), nil
}
